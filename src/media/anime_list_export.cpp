/**
 * Taiga
 * Copyright (C) 2010-2025, Eren Okka
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

#include "anime_list_export.hpp"

#include <QDateTime>
#include <QXmlStreamWriter>
#include <algorithm>
#include <format>
#include <map>
#include <ranges>

#include "base/string.hpp"
#include "base/xml.hpp"
#include "gui/utils/format.hpp"
#include "media/anime.hpp"
#include "media/anime_db.hpp"
#include "media/anime_list.hpp"
#include "sync/myanimelist_utils.hpp"
#include "taiga/version.hpp"

namespace anime::list {

bool exportAsMarkdown(const std::string& path) {
  std::map<anime::list::Status, std::vector<std::string>> status_lists;

  for (const auto& entry : anime::db.entries()) {
    const auto item = anime::db.item(entry.anime_id);
    const auto line =
        std::format("{} ({}/{})", item->titles.romaji, entry.watched_episodes, item->episode_count);
    status_lists[entry.status].push_back(line);
  }

  for (auto& [status, list] : status_lists) {
    std::ranges::sort(list);  // @TODO: case insensitive
  }

  QFile file(QString::fromStdString(path));

  if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) return false;

  QString text;
  for (const auto& [status, list] : status_lists) {
    if (!text.isEmpty()) text += "\n";
    text += u"# %1\n\n"_s.arg(gui::formatListStatus(status));
    for (const auto& line : list) {
      text += u"- %1\n"_s.arg(line);
    }
  }

  file.write(text.toUtf8());
  file.close();

  return true;
}

bool exportAsXml(const std::string& path) {
  constexpr auto format_series_type = [](anime::Type type) {
    // clang-format off
    switch (type) {
      default:
      case anime::Type::Unknown: return "Unknown";
      case anime::Type::Tv: return "TV";
      case anime::Type::Ova: return "OVA";
      case anime::Type::Movie: return "Movie";
      case anime::Type::Special: return "Special";
      case anime::Type::Ona: return "ONA";
      case anime::Type::Music: return "Music";
    }
    // clang-format on
  };

  constexpr auto format_my_status = [](anime::list::Status status) {
    // clang-format off
    switch (status) {
      default:
      case anime::list::Status::Watching: return "Watching";
      case anime::list::Status::Completed: return "Completed";
      case anime::list::Status::OnHold: return "On-Hold";
      case anime::list::Status::Dropped: return "Dropped";
      case anime::list::Status::PlanToWatch: return "Plan to Watch";
    }
    // clang-format on
  };

  base::XmlFileWriter xml;

  if (!xml.open(QString::fromStdString(path))) {
    return false;
  }

  xml.setAutoFormatting(true);
  xml.setAutoFormattingIndent(-1);

  xml.writeStartDocument();

  const auto version = taiga::version().to_string();
  const auto datetime = QDateTime::currentDateTimeUtc().toString(Qt::DateFormat::ISODate);
  xml.writeComment(u" Generated by Taiga v%1 on %2 "_s.arg(version).arg(datetime));

  xml.writeStartElement("myanimelist");

  xml.writeStartElement("myinfo");
  xml.writeNumberElement("user_id", 0);
  xml.writeTextElement("user_name", "");          // @TODO
  xml.writeNumberElement("user_export_type", 1);  // anime
  xml.writeNumberElement("user_total_anime", anime::db.entries().count());
  xml.writeNumberElement("user_total_watching", 0);     // @TODO: anime::list::Status::Watching
  xml.writeNumberElement("user_total_completed", 0);    // @TODO: anime::list::Status::Completed
  xml.writeNumberElement("user_total_onhold", 0);       // @TODO: anime::list::Status::OnHold
  xml.writeNumberElement("user_total_dropped", 0);      // @TODO: anime::list::Status::Dropped
  xml.writeNumberElement("user_total_plantowatch", 0);  // @TODO: anime::list::Status::PlanToWatch
  xml.writeEndElement();                                // myinfo

  for (const auto& entry : anime::db.entries()) {
    const auto item = anime::db.item(entry.anime_id);
    xml.writeStartElement("anime");
    xml.writeNumberElement("series_animedb_id", item->id);
    xml.writeTextElement("series_title", item->titles.romaji);
    xml.writeTextElement("series_type", format_series_type(item->type));
    xml.writeNumberElement("series_episodes", item->episode_count);
    xml.writeTextElement("my_id", 0);
    xml.writeNumberElement("my_watched_episodes", entry.watched_episodes);
    xml.writeTextElement("my_start_date", entry.date_started.to_string());
    xml.writeTextElement("my_finish_date", entry.date_completed.to_string());
    xml.writeTextElement("my_fansub_group", "");
    xml.writeTextElement("my_rated", "");
    xml.writeNumberElement("my_score", entry.score);  // @TODO: translate
    xml.writeTextElement("my_dvd", "");
    xml.writeTextElement("my_storage", "");
    xml.writeTextElement("my_status", format_my_status(entry.status));
    xml.writeTextElement("my_comments", entry.notes);
    xml.writeNumberElement("my_times_watched", entry.rewatched_times);
    xml.writeTextElement("my_rewatch_value", "");
    xml.writeNumberElement("my_downloaded_eps", 0);
    xml.writeTextElement("my_tags", "");
    xml.writeNumberElement("my_rewatching", entry.rewatching);
    xml.writeNumberElement("my_rewatching_ep", entry.rewatching_ep);
    xml.writeNumberElement("update_on_import", 0);
    xml.writeEndElement();
  }

  xml.writeEndElement();  // myanimelist
  xml.writeEndDocument();

  return true;
}

}  // namespace anime::list
